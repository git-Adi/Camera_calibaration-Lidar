# -*- coding: utf-8 -*-
"""4.ipynb

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1-_TBVl4EC6cjHisPgpS8iK-oQ5jV5Jqk
"""

import cv2
import numpy as np
import os
import matplotlib.pyplot as plt
import glob

rows = 6
cols = 8
CHECKERBOARD = (rows,cols)
criteria = (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001)
objpoints = []
imgpoints = []
images = []


# # Defining the world coordinates for 3D points
objp = np.zeros((1, CHECKERBOARD[0] * CHECKERBOARD[1], 3), np.float32)
objp[0,:,:2] = np.mgrid[0:CHECKERBOARD[0], 0:CHECKERBOARD[1]].T.reshape(-1, 2)
prev_img_shape = None

# Extracting path of individual image stored in a given directory
images = glob.glob('./images')
for fname in os.listdir("./images"):
    fname="./images/"+fname
    img = cv2.imread(fname)
    # images.append(img)
    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    ret, corners = cv2.findChessboardCorners(gray, CHECKERBOARD, cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_FAST_CHECK + cv2.CALIB_CB_NORMALIZE_IMAGE)
    if ret == True:
        objpoints.append(objp)
        corners2 = cv2.cornerSubPix(gray, corners, (11,11),(-1,-1), criteria)
        imgpoints.append(corners2)
        img = cv2.drawChessboardCorners(img, CHECKERBOARD, corners2, ret)
    plt.imshow(img)
    plt.title(f"{fname}")
    plt.show()
h,w = img.shape[:2]
ret, mtx, dist, rvecs, tvecs = cv2.calibrateCamera(objpoints, imgpoints, gray.shape[::-1], None, None)

print("Camera matrix : \n")
print(mtx)
print("dist : \n")
print(dist)
print("rvecs : \n")
print(rvecs)
print("tvecs : \n")
print(tvecs)

print("Intrinsic Parameters:     ")
print("Focal Length (fx, fy):", mtx[0, 0], mtx[1, 1])
print("Skew Parameter (s):", mtx[0, 1])
print("Principal Point (cx, cy):", mtx[0, 2], mtx[1, 2])
print("Distortion Coefficients:", dist)
print("RMS reprojection error",ret)

i=0
for fname in os.listdir("./images"):
    fname="./images/"+fname
    img1 = cv2.imread(fname)
    img=cv2.undistort(img1, mtx, dist)
    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    ret, corners = cv2.findChessboardCorners(gray, CHECKERBOARD, cv2.CALIB_CB_ADAPTIVE_THRESH + cv2.CALIB_CB_FAST_CHECK + cv2.CALIB_CB_NORMALIZE_IMAGE)
    if ret == True:
        corners2 = cv2.cornerSubPix(gray, corners, (11,11),(-1,-1), criteria)
        img = cv2.drawChessboardCorners(img, CHECKERBOARD, corners2, ret)
    plt.imshow(img)
    plt.show()
    i+=1
    if i==5:
        break

"""Here, The distrotion effect is less, so that there isn't much change in both images. After the distortion correction, some of the lines appear straight compared to the previous

Reprojections error calculated between image points calculated at first using camera caliberation and object points projected to image plane points using intrinsic and extrinsic parameters calculated.A lower reprojection error indicates a more accurate calibration and reconstruction. It is used to evaluate the accuracy of camera calibration and 3D reconstruction processes
"""

# Compute reprojection error for each image
reproj_errors = []
images = glob.glob('./images')
for idx,fname in enumerate(os.listdir("./images")):
    fname="./images/"+fname
    img = cv2.imread(fname)
    images.append(img)
    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    corners, _ = cv2.findChessboardCorners(gray, CHECKERBOARD)
    if corners is not None:
        img_points_reproj, _ = cv2.projectPoints(objpoints[idx], rvecs[idx], tvecs[idx], mtx, dist)
        error = cv2.norm(imgpoints[idx], img_points_reproj, cv2.NORM_L2) / len(img_points_reproj)
        reproj_errors.append(error)

plt.figure(figsize=(10, 6))
plt.bar(range(len(reproj_errors)), reproj_errors)
plt.xlabel('Image Index')
plt.ylabel('Reprojection Error')
plt.title('Reprojection Error for Each Image')
plt.xticks(range(len(reproj_errors)))
plt.grid(axis='y')
plt.show()

# Compute mean and standard deviation of reprojection error
mean_error = np.mean(reproj_errors)
std_dev_error = np.std(reproj_errors)
print("Mean Reprojection Error:", mean_error)
print("Standard Deviation of Reprojection Error:", std_dev_error)

images = glob.glob('./images')
for idx,fname in enumerate(os.listdir("./images")):
    fname="./images/"+fname
    img = cv2.imread(fname)
    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    ret, corners = cv2.findChessboardCorners(gray, CHECKERBOARD)
    if ret:
        img_corners = cv2.drawChessboardCorners(img.copy(),CHECKERBOARD, corners, ret)
        img_points_reproj, _ = cv2.projectPoints(objpoints[idx], rvecs[idx], tvecs[idx], mtx, dist)
        img_corners2 = cv2.drawChessboardCorners(img.copy(),CHECKERBOARD, img_points_reproj, True)
        plt.figure(figsize=(12,6))
        plt.subplot(1,2,1)
        plt.imshow(img_corners)
        plt.title(f"{fname}")
        plt.subplot(1,2,2)
        plt.imshow(img_corners2)
        plt.title(f"{fname}")
        plt.show()

board_normals = []
for idx,fname in enumerate(os.listdir("./images")):
    fname="./images/"+fname
    img = cv2.imread(fname)
    gray = cv2.cvtColor(img,cv2.COLOR_BGR2GRAY)
    ret, corners = cv2.findChessboardCorners(gray, CHECKERBOARD)
    if ret:
        corners_subpix = cv2.cornerSubPix(gray, corners, (11, 11), (-1, -1), (cv2.TERM_CRITERIA_EPS + cv2.TERM_CRITERIA_MAX_ITER, 30, 0.001))
        bool1,rotvec, tranvec,inlier = cv2.solvePnPRansac(objp, corners_subpix, mtx,dist)
        Rot_mat, _ = cv2.Rodrigues(rotvec)
        normal_world = np.array([0, 0, 1])
        c_normal = np.dot(Rot_mat.T, normal_world)
        c_normal=c_normal/ np.linalg.norm(c_normal)
        board_normals.append(c_normal)


for idx, normal in enumerate(board_normals):
    print(f" Checkerboard Plane Normal {idx + 1} (Oc frame):", normal)

